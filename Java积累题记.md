#### 一、什么是面向对象，什么是面向过程。面向对象的三大基本特征和五大基本原则是什么？

面向过程：把问题分解成一个一个步骤，每个步骤用函数实现，依次调用即可。就是说，面向过程编程的时候，直接定义一个函数，然后使用各种诸如if-else、for-each等方式进行编码执行。

面向对象：将问题分解成一个一个步骤，进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。就是说，在进行面向对象编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。比如想造一辆汽车，先要把车的各种属性定义出来，然后抽象成一个car类。

面向对象的三大特征和五大基本原则？

三大特征：封装、继承、多态

五大基本原则：单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则

#### 二、什么是值传递？什么是引用传递？为什么说Java中只有值传递？

首先要理解值传递、引用传递的概念。

值传递：指在调用函数时，将实际参数<u>复制</u>一份传递到函数中，这样在函数中如果对<u>参数</u>进行修改，将不会影响到实际参数。

引用传递：指在调用函数时，将实际参数的<u>地址</u>直接传递到函数中，那么在函数中对<u>参数</u>所进行的修改，将影响到实际参数。

重点：

|          | 值传递                 | 引用传递               |
| -------- | ---------------------- | ---------------------- |
| 根本区别 | 会创建副本             | 不创建副本             |
| 所以     | 函数中无法改变原始对象 | 函数中可以改变原始对象 |

举例：

```java
public static void main(String[] args){
    ParamTest pt = new ParamTest();
    
    User u = new User();
    u.setName("aaa");
    u.setGender("bbb");
    pt.pass(u);
    System.out.println("print in main , user is " + u);
}

public void pass(User user){
    user = new User();
    user.setName("change aaa");
    user.setGender("change bbb");
    System.out.println("print in pass , user is "+ user);
}
```

输出：

```java
print in pass , user is User{name='change aaa', gender='change bbb'}
print in main , user is User{name='aaa', gender='bbb'}
```

理解：

	这里User u = new User();在堆中给u分配了一个内存地址，存储着aaa，bbb。在pass方法中的形参user接收到的，其实是u的内存地址。也就是说，此时，u和pass的形参user指向的是堆中同一个地址。如果下面没有new User();的操作，那么对user的操作，会直接操作堆中u的对象。这么看来，Java中不是应该是引用传递吗？为什么说是Java中只有值传递呢？其实，这里传递的值是对象的引用地址。而对于普遍认识的基本数据类型，都是传递的副本。所以：<u>1.值传递和引用传递的区别并不是传递的内容，而是实参到底有没有被复制一份给形参。2.Java中其实只存在值传递，只不过对于对象参数，值的内容是对象的引用。</u>

总结：

	无论是值传递还是引用传递，其实都是一种求值策略。在求值策略中，其实还有一种按共享传递。<u>Java的参数传递严格上是按共享传递。</u>

	简单说，Java中的传递，是值传递，而这个值，实际上是对象的引用。

按共享传递：

	指在调用函数时，传递给函数的是实参的地址的拷贝（如果实参在栈中，则直接拷贝该值），在函数内部对参数进行操作时，需要先到拷贝的地址寻找到具体的值，再进行操作。如果该值在栈中，那么因为是直接拷贝值，所以函数内部对参数进行操作，不会对外部变量，产生影响。如果原来拷贝的是原值在堆中的地址，那么需要先根据该地址找到堆中对应的位置，再进行操作。因为传递的是地址的拷贝所以函数内对值的操作对外部变量是可见的。<u>共享传递只是按值传递的一个特例。</u>

#### 三、什么是Java的语法糖？列举你知道的语法糖，如何解语法糖？

语法糖：在计算机语言中添加某种语法，这种语法对语言功能没有影响，但是更方便程序员使用。简而言之，语法糖让程序更加简洁，有更高的可读性。

解语法糖：语法糖主要方便开发人员使用，但其实JVM并不支持这些语法糖，这些语法糖会在编译阶段还原成简单的基础语法结构，这个就是解语法糖。

Java中的语法糖：

1.swich支持String与枚举：字符串的switch是通过equals()和hashCode()来实现的。进行switch的实际是哈希值，然后通过equals方法比较进行安全检查，为了避免哈希碰撞。

2.泛型：对于JVM来说，它并不认识Map<String,String> map这样的语法，需要在编译阶段通过类型擦除的方式，进行解语法糖。

类型擦除的主要过程如下：

将所有的泛型参数用其最左边界(最顶级的父类型)类型替换。移除所有类型参数。

Map<String,String> map = new HashMap<String,String>();

map.put("name","aaa");

解语法糖会变成：

Map map = new HashMap();

map.put("name","aaa");

JVM中没有泛型，只有普通类和普通方法，所有泛型类的类型参数在编译时都会被擦除，泛型类并没有自己独有的Class类对象。比如，不存在List<String>.class或者List<Integer>.class，只存在List.class。

3.自动装箱与拆箱：比如int和Integer，在装箱的过程中是调用包装器的valueOf(int)，方法实现的，而拆箱过程是通过调用包装器的xxxValue()方法实现。

4.方法变长参数：可变参数是在Java1.5中引入的一个新特性，它允许一个方法把任意数量的值作为参数。（String... str）。反编译后其实这就是传入一个数组，数组的长度就是参数的数量。

5.枚举类型：关键字enum可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用。反编译enum的源码，其实就是public final class T extends Enum。当我们创建一个枚举类型的时候，编译器会自动帮我们创建一个final类型的类即成Enum类。

6.内部类：内部类又称为嵌套类，可以把它理解为一个外部类的普通成员。内部类之所以也是一个语法糖，因为他仅仅是一个编译时的概念，outer.java里定义了一个内部类inner，一旦编译成功，就会生成两个完全不同的.class文件，分别是outer.class和outer$inner.class。所以内部类的类名可以和外部类完全相同。

7.条件编译：有时出于程序代码优化的考虑，希望只对其中一部分代码进行编译，此时就需要在程序中加上条件。让编译器只对满足条件的代码编译。（其实就是使用if条件判断实现的，但在Java语言设计之初，就没有引入条件编译的功能，所以在Java中，条件编译很是鸡肋）。

8.断言：assert关键字

9.数值字面量：整数，或者浮点数都允许在数字间加入一个或多个下划线(_)，这些下划线，只是为了方便阅读，不对数值产生任何影响。

10.for-each：其实就是使用了普通的for循环和迭代器

11.try-with-resource：

```java
public static void main(String... args){
    try(BufferedReader br = new BufferedReader(new FileReader("d:\\aaa.xml"))){
        String line;
        While((line = br.readLine())!=null){
            System.out.println(line);
        }
    }catch(IOException e){
        //handle exception
    }
}
```

是不是比在finally中关闭流优雅了许多？其实，反编译后，关闭流的操作都由编译器替你做了。