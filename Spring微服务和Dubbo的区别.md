#### Spring微服务和Dubbo的区别



目前就使用上来说，Dubbo更偏向于内部RPC服务调用，通过定义相关的接口，然后做服务的暴露与消费  

而Cloud是基于Rest API进行RPC接口调用

Dubbo面向服务，Cloud面向服务，更细化

Dubbo的注册中心主要来自于中间件Zookeeper Cloud自身带有Eureka

两者都是分布式架构，而SpringCloud作为官方的一套全家桶解决方案，实现起来更为容易



Spring Cloud 以Rest标准为核心

主要的对象有：消费者、提供者



每一个服务名称通过YML文件进行声明

spring:

  application:

​    name: 服务名称



#### Eruka——注册中心

简单说明：你要调用服务，就需要找到服务

因此Eruka 提供了服务的注册

集群的搭建：通过多台Eruka进行互相注册，搭建起多个注册中心

服务全部都是通过配置注册中心地址的方式来进行注册，集群环境就注册多个

要实现负载均衡，首先要采用同一服务名称，另外要使用Ribbon依赖





#### Ribbon——客户端负载均衡组件

Ribbon实现了客户端调用服务的负载均衡，并且可以进行策略配置

通过Bean LoadBalanced注解创建RestTemplate对象

进行服务名称的识别调用





#### Feign——服务调用技术

客户端调用消费者，消费者服务将与提供者服务进行调用

通常使用Feign进行标识服务，消费者标识为Feign客户端，并声明接口，而提供者实现

接口的功能，通过Feign进行RPC调用，接口跟Dubbo一样定义在中间

双方都依赖





#### Hystrix——熔断器

当某服务挂掉，大量请求等待，导致下层服务都无法得到响应，会形成雪崩效应，这个时候应该及时给请求错误响应或者直接停止服务

错误处理：当服务出现错误的时候，将会调用指定的Fallback处理

服务降级：当服务调用失败，客户端会调用服务中的本地失败处理



服务监控：

HystrixDashboard可用进行单一的服务监控

turbine可用进行多个服务的监控



#### Zuul——网关路由

zull用于对请求进行控制、过滤，作为网关访问拦截，简单的说 就说可以进行拦截URL，服务可以配置地址，然后通过URL,去定向到具体的服务，过滤非法操作

对于Feign调用，要将Feign对应的服务Client改为Zuul，然后将服务中的API，前缀地址加上服务名称，服务要预先配置在Zuul

不采用Zuul的情况下，就直接是消费者调用提供者



#### Config——配置中心

可以将各服务的配置文件统一的托管在GIT、码云等仓库，各服务通过请求CONFIG，CONFIG加载远程仓库，来实现服务配置的统一管理



#### Bus——消息总线

主要和config一起配合，需要使用消息队列，通过刷新的方法，能够在远程仓库配置文件进行数据修改时候，重新加载，注意，模式切换，是无法做到热加载的





#### Stream——消息流

主要是用来方便的处理消息队列数据，整合、管理、操作消息队列





#### Sleuth——链路追踪

主要用于微服务数据采集，服务过多，排查错误比较复杂，当服务互相调用的时候，采用链路追踪可以快捷的查看到服务之间的联系、时间、状态监控，设计上，最好是明确业务调用关系





Feign使用Zuul请求服务的流程

1.请求到达feign接口中的方法上

2.然后二次调用 被zuul识别 然后解析到provider 

3.返回数据结果,如果请求失败,配置熔断,可以进行客户端中断